% !TeX root = ../note.tex
\section{Руководство по установке и использованию}\label{sec:manual}

\subsection{Сервис матчинга}

Матчинг сервис это часть общей системы обработки данных валютной биржи. Он получает ордеры из RabbitMQ, пишет их в MongoDB, находит им пары, совершает сделки и записывает их в Clickhouse.

Запуск сервиса происходит через docker-compose. В корневой директории находится файл docker-compose.yaml, в котором описан запуск и подключение к необходимым сервисам. Сборка и запуск сервиса:

\begin{lstlisting}[language=bash]
docker-compose up -d --build
\end{lstlisting}

Остановка сервиса:

\begin{lstlisting}[language=bash]
docker-compose down  -v
\end{lstlisting}

% \subsubsection{} Сборка сервиса
\textbf{Сборка сервиса}

Первым шагом необходимо склонировать репозиторий. В качестве системы контроля версий используется git, поэтому используем стандартный для него способ:

\begin{lstlisting}[language=bash]
git clone https://<domain-with-git-repository>/matching-engine.git
cd matching-engine
\end{lstlisting}

В Golang используется переменная GOPATH, которая указывает, где должны лежать проекты и их зависимости. Но в нашем случае проект должен собираться вне зависимости от директории, поэтому необходимо включить в Golang поддержку модулей.

\begin{lstlisting}[language=bash]
export GO111MODULE=on
\end{lstlisting}

Последним шагом для установки будет сборка проекта и проверка его работоспособности через запуск бинарного main файла.

\begin{lstlisting}[language=bash]
go build cmd/eme_server/main.go
./main --help # check work
\end{lstlisting}

% \subsubsection{} Запуск сервиса
\textbf{Запуск сервиса}

Необходимо запустить все сервисы, к которым должно вестись подключение из matching сервиса.

Запуск сервиса RabbitMQ:

\begin{lstlisting}[language=bash]
# Starting clickhouse service
systemctl start rabbitmq-server

# Check service status
systemctl status rabbitmq-server
\end{lstlisting}

Запуск сервиса MongoDB:

\begin{lstlisting}[language=bash]
# Starting clickhouse service
systemctl start mongod

# Check service status
systemctl status mongod
\end{lstlisting}

Запуск сервиса Clickhouse:

\begin{lstlisting}[language=bash]
# Starting clickhouse service
systemctl start clickhouse-server

# Check service status
systemctl status clickhouse-server
\end{lstlisting}

Запуск матчинг сервиса:

В бинарном запускаемом файле матчинг сервиса есть опция \lstinline{--config-file <path_to_file>} в которой можно указать конфигурационный файл для с параметрами для запуска. Либо можно использовать любые опции, описанные в \lstinline{./main --help}.

Если никакие настройки во время запуска предыдущих сервисов не были изменены, то могут использоваться стандартные значения для запуска. То есть достаточно будет запустить команду \lstinline{./main}.

Не обязательно указывать все опции при запуске, остальные будут заполнены значениями по умолчанию. Если какие-либо опции указаны и в конфигурации, и в командной строке, то преимущество будет у опций командной строки.

% \subsubsection{} Отправление ордеров
\textbf{Отправление ордеров}

Для отправки ордеров необходимо использовать RabbitMQ. Перед отправкой данных их необходимо сериализовать с помощью protobuf. Лучший способ это сделать с помощью написания клиента, использующего protobuf и RabbitMQ. Пример клиента приведён ниже на языке Golang.

Первым делом необходимо сгенерировать protobuf файлы для выбранного языкка клиента. Это можно сделать с помощью компилятора protobuf — protoc.

\begin{lstlisting}[language=bash]
protoc -I rpc/ rpc/interface.proto --go_out=plugins=grpc:rpc/   # for golang
protoc interface.proto --js_out=library=interface:.             # for javascript
\end{lstlisting}

Затем необходимо импортировать полученный файл в проекте.

\begin{lstlisting}[language=Golang]
import "matching-engine/rpc"
\end{lstlisting}

Пример использования сгенерированных структур:

\begin{lstlisting}[language=Golang]
// First construct object from struct given by file from 2 step
order := rpc.Order{IsPurchase: true, Value: 100, Price: 10, UserID: 1}

// Second serialize it with protobuf
serializedOrder, _ := proto.Marshal(&order)

// Third constrcut message from geneted file struct Msg
msg := rpc.Msg{Act: rpc.Action_CREATE, Data: serializedOrder}

// Fourth serialize it by protobuf
serializedMsg, _ := proto.Marshal(&msg)
\end{lstlisting}

Пример отправки данных в RabbitMQ очередь:

\begin{lstlisting}[language=Golang]
conn, err := amqp.Dial("amqp://guest:guest@localhost:5672")
ch, err := conn.Channel()

queue, err := ch.QueueDeclare("hello", false, false, false, false, nil)

ch.Publish("", queue.Name, false, false,
    amqp.Publishing{DeliveryMode: amqp.Persistent, Body: serializedMsg})

ch.Close()
conn.Close()
\end{lstlisting}

% \subsubsection{} Прослушивание Redis-событий
\textbf{Прослушивание Redis-событий}

Доступные каналы для прослушивания:

\begin{itemize}
    \item CreatedOrder;
    \item UpdatedOrder;
    \item RemovedOrder;
    \item CreatedTrade;
    \item Errors;
\end{itemize}

Из всех каналов, кроме канала ``UpdatedOrder'' приходят массивы данных в JSON.

Пример полей для объекта сделки:

\begin{lstlisting}[language=JavaScript]
// trade json
{
    "ID":0,
    "OrderIDBuy":0,
    "OrderIDSell":1,
    "UserIDBuy":1,
    "UserIDSell":2,
    "Value":100,
    "Price":10,
    "Time":"2019-10-25T09:30:40.620096209Z"
}

// orders json
{
    "ID":0,
    "UserID":1,
    "Value":0,
    "Price":10,
    "IsPurchase":true,
    "InitialValue":100,
    "IsClosed":true
}
\end{lstlisting}

Пример подписывания на события из Redis:

\begin{lstlisting}
# connection
redis-cli -h $(REDIS_IP) -p $(REDIS_PORT)

# list channels
>> pubsub channels *

# subscribe to channel
>> subscribe CreatedOrder
\end{lstlisting}

\subsection{Сервис балансов}

Объект баланса в базе данных состоит из идентификатора, размера средств и замороженного баланса, который сейчас занят ордерами.

Сборка проекта, запуск сторонних сервисов и сервиса балансов происходят так же, как и у сервиса матчинга.
При успешном запуске должно быть показано следующее сообщение

\begin{lstlisting}
Hello, I am Balance Server!
Node configuration: 
	Name of node:              USD balances
	Currency:                  USD
	Mongo connect:             mongodb://192.168.9.241:11111/test?maxidletimems=1000
	Mongo collection:          usd
	RabbitMQ address:          amqp://test:test@192.168.9.241:22222/testvhost
	RabbitMQ name:             usd-balance
	Redis address:             192.168.9.241:33333
	Log level:                 warn
	Error file:                errors.log
\end{lstlisting}

Сервис балансов поддерживает 5 видов сообщений:

\begin{enumerate}
    \item \lstinline{Action_WITHDRAWAL} — используется для снятия средств с баланса пользователя;
    \item \lstinline{Action_DEPOSIT} — используется для пополнения баланса пользователя;
    \item \lstinline{Action_FREEZING} — используется для заморозки части пользовательского баланса при создании ордера;
    \item \lstinline{Action_UNFREEZING} — используется для разморозки средств, которые были потрачены в сделке;
    \item \lstinline{Action_TRANSFER} — используется для перевода средств между пользователями.
\end{enumerate}

Все сообщения используют такие же названия, как и типы данных: WithdrawalData, DepositData, FreezingData, UnfreezingData, TransferData.

% \subsubsection{} События
\textbf{События}

События могут получены из следующих каналов:

\begin{itemize}
    \item DepositBalance;
    \item WithdrawalBalance;
    \item FreezingBalance;
    \item UnfreezingBalance.
\end{itemize}

Каждый канал имеет в своём названии префикс, соответствующий валюте, для которой канал предназначен. Например для доллара: USDDepositBalance, USDWithdrawalBalance и т.д. События из каналов приходят в виде JSON массивов.

Пример события DepositBalance:

\begin{lstlisting}
[
    {
        "UserID":852,
        "Value":85100
    },
    {
        "UserID":853,
        "Value":85200
    },
    {
        "UserID":854,
        "Value":85300
    },
    {
        "UserId":855,
        "Value":85400
    }
]
\end{lstlisting}

Для сообщения о трансфере нет отдельного события, так как при трансфере есть два события: WithdrawalBalance — для посылающего пользователя, DepositBalance — для принимающего.

Подписка на сообщения в Redis происходит так же, как и в матчинг сервисе.
